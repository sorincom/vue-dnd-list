<template>
  <div
    @dragstart="onDragStart"
    @dragend="onDragEnd"
    :draggable="draggable"
    ref="rootRef">
    <div style="pointer-events: none;">
      <slot></slot>
    </div>
  </div>
</template>

<script>

import { ref, onBeforeMount, onBeforeUnmount } from 'vue'

/// Custom drag and drop related events generated by a list item
const useDnDItemEvents = function(props, emit, rootRef) {

  // Item started being dragged
  const onDragStart = (evt) => {
    const effect = props.copyOnDrag ? 'copy' : 'move'
    evt.dataTransfer.dropEffect = effect
    evt.dataTransfer.effectAllowed = effect
    evt.dataTransfer.setData('item', JSON.stringify(props.item))
    emit('dnd:drag-started', {index: props.index})
  }

  // Item stopped being dragged
  const onDragEnd = () => {
    emit('dnd:drag-ended', {index: props.index})
  }

  // Check if something is being dragged over this item.
  // Working with window events because they are more reliable, not
  // being affected by the item's children generating dnd events.
  function dragOverWindow(evt) {
    evt.preventDefault()    
    const el = rootRef.value
    const rect = el.getBoundingClientRect()
    const draggingOver =
      evt.clientY >= rect.top &&
      evt.clientY <= rect.bottom &&
      evt.clientX >= rect.left &&
      evt.clientX <= rect.right
    if (draggingOver) {
      const draggedOverTopHalf = (evt.clientY < rect.top + rect.height / 2)
      const position = draggedOverTopHalf ? 'before' : 'after'
      emit('dnd:drag-over', {index: props.index, position})
    }
  }

  // Maybe use intersection observer to avoid wiring upfront tons of handlers,
  // one for each item in the list?
  onBeforeMount(() => {
    window.addEventListener("dragover", dragOverWindow)
  })

  onBeforeUnmount(() => {
    window.removeEventListener("dragover", dragOverWindow)
  })

  return {
    onDragStart,
    onDragEnd
  }
}

export default {
  name: "DnDListItem",
  props: {
    item: {
      required: true
    },
    index: {
      required: true
    },
    draggable: {
      type: Boolean,
      default: false
    },
    copyOnDrag: {
      type: Boolean,
      default: false
    }
  },
  setup(props, { emit }) {
    const rootRef = ref(null)
    return {
      rootRef,
      ...useDnDItemEvents(props, emit, rootRef),
    }
  },
}

</script>
